https://howtodoinjava.com/java/basics/java-classes-objects/

Instance variables in Java are non-static variables which are defined in a class outside any method, constructor or a block
Instance variables are declared without static keyword.
Class variables (Static variable) are declared with keyword static


<<<<<<<<<<<<Instance Initialization Block: InstanceInitialization.java

All initializers are executed automatically in textual order for every object we create.
Code for all instance initializers are executed before any constructor.
An instance initializer cannot have a return statement.

<<<<<<<<<<<<Static Initialization Block: StaticInstanceInitialization.java
An instance initializer is executed once per object whereas a static initializer is executed only once
for a class when the class definition is loaded into JVM.
All static initializers are executed in textual order in which they appear, 
and execute before any instance initializers.

<<<<<<<<<<<Java Operators  https://howtodoinjava.com/java/basics/operators-in-java/
An operator is a symbol that performs a specific kind of operation on one, two, or three operands, and 
produces a result

Arithmetic Operators:
These operators cannot have operands of boolean primitive type and reference type.
The string concatenation operator is also used to concatenate a primitive and a reference data type 
value to a string.


BitWise Operator :

Bitwise Complement Operator:
It is important to note that the bitwise complement of any integer N is equal to - (N + 1)

https://medium.com/@mirandarevans/why-does-the-twos-complement-represent-negative-numbers-244dcc327809

Sum of Number from 1 to n ==  n (n+1) /2  ##can me used in find one missing number

<<<<<<<<<<<<<<<<<<<Java Data types >>>>>>>>>>>>..
#####stack vs heap
* Stack memory contains primitive data type of methods and reference variables.While Heap memory contains object
* Whenever new key word is used. memory is created in HEAP and it is assigned to the reference variabe using assignment operator(=)
*A reference variable refers to where the actual object resides in heap memory

** when assigning higher data type value to smaller one (type-mismatch error and explicitly asks for type casting)
** Casting from bigger data type to smaller one may result in data loss

#####Auto boxing
In Java, you can assign a primitive type value to a wrapper class, directly. 
For example, you can assign a int value to Interger class reference.

Integer counter = 20;
static Float PI = 3.14f;

######Auto Unboxing
Unboxing happens when the conversion happens from wrapper class to its corresponding primitive type
Integer x = new Interger (10)
int xx = x; // wrapper to primitive

<<<<<<<<<<<<<<<<<Variable type>>>>>>>>>>>>>>>>
Instance variable
Static Variable
Local variable
method args

Instance variables in Java are non-static variables which are defined in a class outside any method, constructor or a block
Instance variables are declared without static keyword.
Class variables (Static variable) are declared with keyword static
Local variable are declared inside methods

<<<<<<<<<<<<<<<<<Public static void main>>>>>>>>>>>>>>>>
https://howtodoinjava.com/java/basics/main-method/

Public ::  Because it can be invoked from any where. If private it cant be invoked.
Static ::  If its not static , we have to create an instance of this object.
And What if we dont have a default constrctor (without args in out class) . If we have constructor with some args
how will the jvm know the values..That y its made static.. We can  call it just with class name

Void :: We are not going to call this main method in our program. ONly JVM calls this method
So it does not require any return value

<<<<<<<<<<<<<<<<<When to use Wrapper Class>>>>>>>>>>>>>>>>
https://howtodoinjava.com/java/basics/java-wrapper-classes/
1)Generics & Collecetion work with Wrapper classer
2)When you want to assign null value . Cant set null value for primitives
3)When two method wanna refer same instance of primitive type ,then pass wrapper class as arg


<<<<<<<<<<<<<<<<<JAVA - PASS BY VALUE>>>>>>>>>>>>>>>>
https://howtodoinjava.com/java/basics/java-is-pass-by-value-lets-see-how/
Java is passby value..
When you pass an instance to a method, its memory address are copied bit by bit to new reference variable, 
thus both pointing to same instance. But if you change the reference inside method, original reference will not get change. 
If it was pass by reference, then it would have got changed also.

*** When you assign a new instance to formal parameter , then only formal param reference is changed..
The actual param will have the same reference..


<<<<<<<<<<<<<<<<<HASH CODE AND EQUALS>>>>>>>>>>>>>>>>
https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/
Equals::::
It’s default implementation simply check the object references of two objects to verify their equality. 
By default,two objects are equal if and only if they are stored in the same memory address.


Why override both ??
It is generally necessary to override the hashCode() method whenever equals() method is overridden, 
so as to maintain the general contract for the hashCode() method, 
which states that equal objects must have equal hash codes.

hashcode() Used in hashing Algorithm.. Like hashset (Which adds  unique value using hash map put)

* If two objects have the same hash code, it doesn't mean that they are equal. 
check EqualsOverridenInStringClass.java (==)




#####serialization / deserialization -->  https://stackoverflow.com/questions/285793/what-is-a-serialversionuid-and-why-should-i-use-it
--- When sending an object from servlet to JSP (req.setattribute) then the object is utilized in JSP by req.getattribute and assigned to a Object
--- This serial version id is used to check whether sent object and loaded object in jsp are same
https://www.baeldung.com/java-serial-version-uid#:~:text=The%20serialVersionUID%20attribute%20is%20an,object%20of%20a%20Serializable%20class.

If we don't define a serialVersionUID state for a Serializable class, 
then Java will define one based on some properties of the class itself such as the class name, instance fields, and so on.
This will create problem if any new field is added to class

#####immutable class

https://howtodoinjava.com/java/basics/how-to-make-a-java-class-immutable/
https://www.journaldev.com/129/how-to-create-immutable-class-in-java
ImmutableClass/TestMain 
* Final class .. So that it cant be Extended
* Don’t provide “setter” methods 
* Make all fields final and private
* Special attention when having mutable instance variables
* Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.
Immutable object is simple, thread-safe (no need synchronization), less prone to error and more secure. 
If possible, make all objects immutable.


Other Reference :
https://www.interviewcake.com/concept/java/mutable
https://www.mkyong.com/java/java-mutable-and-immutable-objects/

//Read -- https://howtodoinjava.com/java/collections/hashmap/shallow-deep-copy-hashmap/
//https://stackoverflow.com/questions/28288546/how-to-copy-hashmap-not-shallow-copy-in-java/28288729

String pool is possible only because String is immutable in Java.

<<<<<<<<<<<<<<<<OOPS>>>>>>>>>>>>>>>>>

Class -> state & behaviour

** If we do not provide any constructor, JVM assigns a default constructor to the class. 
This default constructor does not accept any parameter.

** if we assign a constructor to any class then JVM does not assign the default constructor to it. 
If needed, we need to specify the default constructor explicitly to the class.


###Access Modifier / Access Specifier
Refer : Java note & https://howtodoinjava.com/java/oops/java-access-modifiers/

public – accessible everywhere
protected – accessible in the same package and in sub-classes
default – accessible only in the same package
private – accessible only in the same class
public > protected > package-private (or default) > private

//A Top level class can be  either public or default
//A Top level class cannot be protected or private
//But an inner class can be protected or private

### Constructors
https://howtodoinjava.com/java/oops/java-constructors/
If no constructor is declared inside class ,then jvm creates a default constructor
Once we declare a parametirized constructor and if the class dont have defalut constructor
then object cant be created with default constructor
Default constructor
Parameterized constructor
Private constructor-- in singleton

Constructor chainging ::
Calling same class constructor
Calling Super clas constructor

If you want to use super() i.e. 
super class constructor then it must be first statement inside constructor.

<<<<<<<<<<<<<<<<<<<<<OOPS>>>>>>>>>>>>>>>>>>>
#####Abstraction
--Instance cant be created for an abstract class
Abstraction is more about hiding the implementation details. 
In Java abstraction is achieved through abstract classes and interfaces.

Ex: Creating contracts. The clients is saying like he need to have two methods.
one is get and then put() . put() should insert data and get should retrieve the data.
He doesnt care about the internal implementation
Ex: Map
What we mostly use in out program is get() and put() method of map
We dont care about what it internally does (Hashmap). This is abstraction

Ex: In sella ,using two diff servlet INTERNET and INTRANET
In one servlet we use one channel id to create token
In other servlert, we use diff channel id to create token

#####Encapsulation
--Must read last para
https://howtodoinjava.com/java/oops/encapsulation-in-java-and-its-relation-with-abstraction/

A Java class, where all instance variables are private and only the methods within the class 
can manipulate those variables, is an example of an encapsulated class.
Wrapping data and methods within classes in combination with 
implementation hiding (through access control) is often called encapsulation. 
Encapsulation essentially has both i.e. information hiding and implementation hiding.

Private variables and public method
Whatever changes , Encapsulate it..

Abstraction is more about ‘What‘ a class can do. [Idea] {{get and put method in MAP}}
Encapsulation is more about ‘How‘ to achieve that functionality. [Implementation]
{{{Hashmaps logic to store using put() and retrieve using get() }}}
ArrayList is also an example of Encapsulation.

Putting getter method and setter method in seperate interface and implementing
in encapsualteion class


For ex :age may differ every year..
So we have a dob variable in Class and to get age we invent a method getAge()
Which has the logic of getting age from dob..

Ex 2:
Decoding and Encoding password in getPwd and set pwd methods


#####Inheritance (IS-A relationship)
Inheritance in java (IS-A relationship) is referred to the ability where child objects inherit or acquire all the properties 
and behaviors from parent object. 
In object oriented programming, inheritance is used to promote the code re-usability.
A sub class (child class) can inherit all non-private members from super class, by default.


{{{{{{{ReferenceClass variable = new ActualClass();}}}}}}}}
### java fields cannot be overridden
//Parent fields can't be over ridden {{Based on reference the field value will be fetched}}
//Parent methods will be overridden

Member fields are accessed from reference type class.
Member methods are accessed from actual instance types.


#####Polymorphism
One name multiple form
1)Compile time polymorphism (static binding or method overloading)
2)Runtime polymorphism (dynamic binding or method overriding)

operator overloading is also there, 
e.g. “+” operator can be used to add two integers as well as concat two sub-strings.

Check Overloading Rules & Overriding Rules.
Super class : overridden method
Child class : overriding method

Method Overloading Rules :
1)Signature must vary (no.args, arg types ,order of args)
2)changing return type is not considerd as overloading
3)Exception also not matter in overloading

Method Overriding Rules:
1)argument list in both methods are same
2)return type of overriding method can be child class of return type declared in overridden method.
3)private, static and final methods can not be overridden
4)Overriding method can not throw checked Exception higher in hierarchy than thrown by overridden method.
5)Cannot reduce the scope of overriding method (public to protected )
but can be (protected to public)


###### Interface vs abstract class 
https://howtodoinjava.com/java/oops/exploring-interfaces-and-abstract-classes-in-java/
1)In interface all methods are public abstract .But the case is different in abstract class
(accessibility cant be reduced)
2)Interface can be utilised with implements key word & and abstract class can be utilized with extends keyword


Example of abstract Class:
Abstract classes let you define some behaviors;
HttpServelet is abstract class which defines all life cycle methods( i.e. initialization, service, and destruction)
So that we can concentrate only on business
Example of Interface :
Map is an interface implemented by Hashmap ,treemap, hashtable, weekhashmap

$$$$Interface vs abstract class  (After java 8:)
THe interface are started supported default methods
So the diff between absrtact & interface are made thin
Now, only one big difference remains that you cannot extend multiple classes 
whereas you can implement multiple interfaces. 

######Default Methods in Interface : (In Java 8)
-->Default methods can be overridden 
-->Default can be public and cannot be protected ,private
--> only public, abstract, default, static and strictfp are permitted in interfaces
For Ex : ForEach feature is introduced as default method in java 8

######Multiple Inheritance

ConstantsAndAbstraceMethod.java class
**If both interface has same param name ,it cant be used as-such in child class
It should be used with interfacename. {{Interface.param}} since its static final we can call
with interface name itself
Error thrown :The field param is ambiguous
This is not possible with Classes ,as it may or may-not have static field.

CONSTANTS::
Same constants name from multiple interfaces  is allowed provided that calls are not ambigious

ABSTRACT METHOD:
Same abstract method names are allowed provides that they are properly loaded or 
they have same signature (return type , same type of input params)

DEFAULT METHODS:
1)If both interface has default method with same name and signature
and both are implemented in  a class. Then it should be over ridden.

Idefault1 & Idefault2 has default method work()
When both are implemented in DefaultRules.java class.
Then it must be over ridden.
2)Over loaded version works

STATIC METHODS:
Cannot be over ridden. So no problem

<<<<Other Oops concepts>>>
https://howtodoinjava.com/java/oops/association-aggregation-composition/
######Association
->objects have an independent lifecycle {Two object are in dependent of each other}
->Mutliple student for single teacher // Single student for many teacher
-> if the student leave the school , we dont need to delete teacher and vice versa...

/There are two forms of association
//Composition
//Aggregation

######Aggregation
->Objects have an independent lifecycle, but there is ownership, 
and child objects cannot belong to another parent object.
Ex : mobile phone and mobile battery

######Composition
->Object don’t have an independent lifecycle, 
Composition is an association represents a part of a whole relationship
where a part cannot exist without a whole. 
If a whole is deleted then all parts are deleted. It has a stronger relationship.
--If we delete the order object , the line items will be deleted

<<<<<Inner classes>>>>>>
-> Non static nested classes ( inner class)
-> Static nested class
-> Anonymous inner class (Classes created with $1 , $2)
Why can't we have static method in a (non-static) inner class?
The field instance cannot be declared static in a non-static inner type, 
unless initialized with a constant expression

Double brace init is example for using anonymous inner class 
https://howtodoinjava.com/java/inner-classes/double-brace-initialization-in-java/

######Enumeration
//https://howtodoinjava.com/java/enum/enum-tutorial/
public enum Direction 
{
   EAST, WEST, NORTH, SOUTH;
}
-> JVM internally adds ordinal and value methods
final class Direction extends Enum&lt;Direction&gt; 
{
    public final static Direction EAST = new Direction();
    public final static Direction WEST = new Direction();
    public final static Direction NORTH = new Direction();
    public final static Direction SOUTH = new Direction();
}
 Also, all enum types in Java are singleton by default.

######Collection
//Refer Ganesh innovative note book 
https://howtodoinjava.com/java-collections/ --- Check all the collections
https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java
https://stackoverflow.com/questions/948194/difference-between-java-enumeration-and-iterator#:~:text=1)%20The%20main%20difference%20between,not%20have%20remove()%20method.&text=Iterator%20is%20not%20a%20legacy%20interface.
https://www.geeksforgeeks.org/fail-fast-fail-safe-iterators-java/#:~:text=Iterator%20on%20ArrayList%2C%20HashMap%20classes,examples%20of%20fail%2Dfast%20Iterator.&text=This%20is%20because%2C%20they%20operate,examples%20of%20fail%2Dsafe%20Iterator.

PECS (Producer extends and Consumer super)
mnemonic -> Get and Put principle.
This principle states that:
Use an extends wildcard when you only get values out of a structure.
Use a super wildcard when you only put values into a structure.
And don’t use a wildcard when you both get and put.

"PECS" is from the collection's point of view. 
If you are only pulling items from a generic collection, it is a producer and you should use extends; 
if you are only stuffing items in, it is a consumer and you should use super. 
If you do both with the same collection, you shouldn't use either extends or super.
Array List :
Size is incremented  by 50% once reached threshold.


#####"FAIL FAST"::"FAIL SAFE"
https://www.geeksforgeeks.org/fail-fast-fail-safe-iterators-java/#:~:text=Iterator%20on%20ArrayList%2C%20HashMap%20classes,examples%20of%20fail%2Dfast%20Iterator.&text=This%20is%20because%2C%20they%20operate,examples%20of%20fail%2Dsafe%20Iterator.
https://www.baeldung.com/java-fail-safe-vs-fail-fast-iterator

Concurrent Modification in programming means to modify an object concurrently when another task is 
already running over it. For example, in Java to modify a collection(add / put/ remove) when another thread is iterating over it.
Some Iterator implementations (including those of all the general purpose collection implementations
provided by the JRE) may choose to throw ConcurrentModificationException if this behavior is detected.


Iterators are fail-fast . i.e. when one thread changes the collection by add / remove operations ,
while another thread is traversing it through an Iterator using hasNext() or next() method,
the iterator fails quickly by throwing ConcurrentModificationExceptiom

Iterator on ArrayList, HashMap classes are some examples of fail-fast Iterator.
Iterators on Collections from java.util.concurrent package s
uch as ConcurrentHashMap, CopyOnWriteArrayList, etc. are Fail-Safe in nature.



(Fail-Safe iterators don’t throw any exceptions if a collection is structurally modified while iterating over it. 
This is because, they operate on the clone of the collection, 
not on the original collection and that’s why they are called fail-safe iterators)

Enumeration are not fail fast as they used in hash table .. which are synchronized

**********************************************************************************************************
**********************************************************************************************************


####Sorting
Array sorting , List sorting , map sorting based on key , values
parallel sorting



####Cloning
https://howtodoinjava.com/java/cloning/a-guide-to-object-cloning-in-java/

Original object & cloned object will have different memory address

JVM when called for cloning, do following things:

1) If the class has only primitive data type members then a completely new copy of the object will be created 
and the reference to the new object copy will be returned.
2) If the class contains members of any class type then only the object references to those members are copied and 
hence the member references in both the original object as well as the cloned object refer to the same object.

In java, if a class needs to support cloning it has to do following things:
You must implement Cloneable interface.
You must override clone() method from Object class.
[Its weird. clone() method should have been in Cloneable interface.]


**deep copy & shallow copy in cloning**


***********************************************************************************************
***********************************************************************************************

###################  Multi Threading And Concurrency ###############
https://howtodoinjava.com/java-concurrency-tutorial/

Concurrency is the ability to run several programs or several parts of a program in parallel.
Completing task much before in time in comparison to sequential processing.

1 ) MainThread1.java -> shows diffrence b/w normal sequential execution vs two thread process

2 ) Two threads working with shared data
MainThread2.java -> Counter variable share between multiple threads 

******Thread Safety:
A piece of code is thread-safe if it only manipulates 
shared data structures in a manner that guarantees safe execution by multiple threads at the same time.
A class is thread-safe when it continues to behave correctly when accessed from multiple threads.

******Concurrency vs. parallelism
Concurrency : Multiple task in over lapping time
Parrellism : eg: sorting ( It processes multiple sub-tasks of a task in multi-core CPU at same time.)
Concurrency is the composition of independently executing processes, (logging data in database)
while parallelism is the simultaneous execution of (possibly related) computations.(parallel sorting)
Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.

******The synchronized keyword can be use with –
A) code block ( Using lock object )
B) method

******object-vs-class-level-locking
https://howtodoinjava.com/java/multi-threading/object-vs-class-level-locking/
Object level lock  : non-static method or non-static code block 
class level lock  : Static method or static block (Single ton class )

**Classlevel sync on method
public static AuParamDao getInstance() {
		if(instance==null) {
			synchronized (AuParamDao.class) {
				if(instance==null) {
					instance = new AuParamDao();
				}
			}
		}
		return instance;
	}
	
***Sync with shared object	 (point no 10)
create a new private scoped Object instance (private Object lock = new Object())
OR
 lock on the shared variable itself which we want to protect. 
private static Cache<String,ServizioEsterno> serviziEsterni=CacheFactory.getInstance(ServiziEsterniGateway.class).getCacheInstance(cacheInfo);
synchronized (serviziEsterni) {
//code
}	




***********************************************************************************************
***********************************************************************************************



########Before Interview
1)jdk vs jre vs jvm

2)final keyword

3)can we assign null to primitive types ? #no

4)stack vs heap
https://www.journaldev.com/4098/java-heap-space-vs-stack-memory
https://www.guru99.com/java-stack-heap.html
https://www.youtube.com/watch?v=UcPuWY0wn3w
https://www.youtube.com/watch?v=jzJjMefsFKE

5)serialization / deserialization -->  https://stackoverflow.com/questions/285793/what-is-a-serialversionuid-and-why-should-i-use-it
--- When sending an object from servlet to JSP (req.setattribute) then the object is utilized in JSP by req.getattribute and assigned to a Object
--- This serial version id is used to check whether sent object and loaded object in jsp are same
https://www.baeldung.com/java-serial-version-uid#:~:text=The%20serialVersionUID%20attribute%20is%20an,object%20of%20a%20Serializable%20class.
6)Eclipse has its own java compiler --> https://stackoverflow.com/questions/47623117/which-java-compiler-is-used-by-eclipse#:~:text=Eclipse%20has%20its%20own%20Java,eclipse.







